<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Holographic Collision Engine</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        :root {
            --bg-deep: #f8fafc;
            --bg-panel: #ffffff;
            --text-main: #334155;
            --text-dim: #64748b;
            
            /* Premium Soft Colors */
            --neon-blue: #3b82f6; /* Soft Blue for M1 */
            --neon-pink: #ec4899; /* Soft Pink for M2 */
            --neon-green: #10b981; /* Soft Green for CM */
            
            --glass-border: 1px solid rgba(0, 0, 0, 0.08);
            --shadow-soft: 0 4px 20px rgba(0, 0, 0, 0.05);
            --shadow-hover: 0 8px 30px rgba(0, 0, 0, 0.08);
        }

        body {
            font-family: 'Inter', system-ui, sans-serif;
            background-color: var(--bg-deep);
            color: var(--text-main);
            margin: 0;
            padding: 20px;
        }

        .main-layout {
            max-width: 1400px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 320px 1fr;
            gap: 25px;
        }

        /* Header */
        header { 
            grid-column: 1 / -1; 
            margin-bottom: 10px; 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            padding: 10px 0;
        }
        
        h1 { 
            margin: 0; 
            font-weight: 400; 
            letter-spacing: 1px; 
            color: var(--text-main);
            position: relative;
        }
        
        h1::after {
            content: "";
            position: absolute;
            bottom: -5px;
            left: 0;
            width: 100%;
            height: 2px;
            background: linear-gradient(to right, var(--neon-blue), var(--neon-pink));
            border-radius: 2px;
        }

        /* Sidebar Controls */
        .control-panel {
            background: var(--bg-panel);
            border: var(--glass-border);
            border-radius: 16px;
            padding: 20px;
            height: fit-content;
            box-shadow: var(--shadow-soft);
            transition: box-shadow 0.3s ease;
        }
        
        .control-panel:hover {
            box-shadow: var(--shadow-hover);
        }

        .input-group { 
            margin-bottom: 20px; 
            position: relative;
        }
        
        .input-group::after {
            content: "";
            position: absolute;
            bottom: -10px;
            left: 0;
            width: 100%;
            height: 1px;
            background: linear-gradient(to right, transparent, rgba(0,0,0,0.05), transparent);
        }
        
        .group-title { 
            font-size: 0.75rem; 
            color: var(--text-dim); 
            text-transform: uppercase; 
            letter-spacing: 1px; 
            margin-bottom: 10px; 
            border-bottom: 1px solid rgba(0,0,0,0.05); 
            padding-bottom: 5px; 
        }

        .row { 
            display: flex; 
            align-items: center; 
            justify-content: space-between; 
            margin-bottom: 10px; 
        }
        
        label { 
            font-size: 0.9rem; 
            font-weight: 500; 
        }

        /* Styled Inputs */
        input[type="number"] {
            background: rgba(255, 255, 255, 0.8);
            border: 1px solid rgba(0,0,0,0.1);
            color: var(--text-main);
            border-radius: 6px;
            padding: 6px;
            width: 70px;
            text-align: center;
            font-family: monospace;
            transition: all 0.2s;
        }
        
        input[type="number"]:focus { 
            border-color: var(--neon-blue); 
            outline: none; 
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.1);
        }

        /* Premium Button */
        .btn-glow {
            width: 100%; 
            padding: 15px;
            background: linear-gradient(90deg, var(--neon-blue), #8b5cf6);
            color: #fff; 
            border: none; 
            border-radius: 8px;
            font-weight: 600; 
            text-transform: uppercase; 
            letter-spacing: 1px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(59, 130, 246, 0.3);
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }
        
        .btn-glow::before {
            content: "";
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }
        
        .btn-glow:hover { 
            box-shadow: 0 6px 20px rgba(59, 130, 246, 0.4); 
            transform: translateY(-2px);
        }
        
        .btn-glow:hover::before {
            left: 100%;
        }

        /* Canvas Area */
        .viz-grid {
            display: grid; 
            grid-template-columns: 1fr 1fr; 
            gap: 20px;
        }
        
        .viz-card {
            background: var(--bg-panel);
            border: var(--glass-border);
            border-radius: 16px;
            position: relative;
            overflow: hidden;
            box-shadow: var(--shadow-soft);
            transition: box-shadow 0.3s ease;
        }
        
        .viz-card:hover {
            box-shadow: var(--shadow-hover);
        }
        
        .card-label {
            position: absolute; 
            top: 15px; 
            left: 15px;
            font-size: 0.7rem; 
            font-weight: bold; 
            color: var(--neon-green);
            background: rgba(16, 185, 129, 0.1);
            padding: 4px 10px; 
            border-radius: 4px; 
            border: 1px solid rgba(16, 185, 129, 0.2);
            z-index: 10;
        }

        canvas {
            display: block; 
            width: 100%; 
            height: 400px;
            background: radial-gradient(circle at center, #f1f5f9 0%, #e2e8f0 100%);
        }

        /* Stats Bar */
        .stats-bar {
            display: grid; 
            grid-template-columns: repeat(4, 1fr); 
            gap: 15px; 
            margin-top: 20px;
        }
        
        .stat-item {
            background: rgba(255,255,255,0.7); 
            padding: 15px; 
            border-radius: 10px; 
            text-align: center;
            border: 1px solid rgba(0,0,0,0.05);
            box-shadow: var(--shadow-soft);
            transition: all 0.3s;
        }
        
        .stat-item:hover {
            transform: translateY(-3px);
            box-shadow: var(--shadow-hover);
        }
        
        .stat-val { 
            font-size: 1.2rem; 
            font-weight: bold; 
            font-family: monospace; 
            color: var(--text-main); 
        }
        
        .stat-label { 
            font-size: 0.7rem; 
            color: var(--text-dim); 
            margin-top: 5px; 
        }

        /* Responsive */
        @media (max-width: 900px) {
            .main-layout { grid-template-columns: 1fr; }
            .viz-grid { grid-template-columns: 1fr; }
            .stats-bar { grid-template-columns: 1fr 1fr; }
        }
    </style>
</head>
<body>

<div class="main-layout">
    <header>
        <h1>Holographic Collision <span style="color:var(--neon-blue); font-size:0.6em; vertical-align:middle;">PRO</span></h1>
    </header>

    <aside class="control-panel">
        <div class="input-group">
            <div class="group-title" style="color:var(--neon-blue)">Particle 1 (Blue)</div>
            <div class="row"><label>Mass (kg)</label><input type="number" id="m1" value="4"></div>
            <div class="row"><label>Vel ($u_1$)</label><input type="number" id="u1" value="10"></div>
        </div>

        <div class="input-group">
            <div class="group-title" style="color:var(--neon-pink)">Particle 2 (Pink)</div>
            <div class="row"><label>Mass (kg)</label><input type="number" id="m2" value="6"></div>
            <div class="row"><label>Vel ($u_2$)</label><input type="number" id="u2" value="0"></div>
        </div>

        <div class="input-group">
            <div class="group-title">Physics Engine</div>
            <div class="row"><label>Restitution ($e$)</label><input type="number" id="e" value="0.9" step="0.1" max="1" min="0"></div>
            <div class="row"><label>Angle ($\chi$)</label><input type="number" id="chi" value="60"></div>
        </div>

        <button class="btn-glow" id="btn-run">Initialize System</button>
    </aside>

    <main>
        <div class="viz-grid">
            <div class="viz-card">
                <div class="card-label">LABORATORY FRAME</div>
                <canvas id="cvs-lab"></canvas>
            </div>
            <div class="viz-card">
                <div class="card-label">CENTER OF MASS FRAME</div>
                <canvas id="cvs-cm"></canvas>
            </div>
        </div>

        <div class="stats-bar">
            <div class="stat-item">
                <div class="stat-val" style="color:var(--neon-green)" id="out-vcm">--</div>
                <div class="stat-label">System $V_{cm}$</div>
            </div>
            <div class="stat-item">
                <div class="stat-val" style="color:#f59e0b" id="out-loss">--</div>
                <div class="stat-label">Energy Loss (Q)</div>
            </div>
            <div class="stat-item">
                <div class="stat-val" id="out-v1">--</div>
                <div class="stat-label">Final Speed $v_1$</div>
            </div>
            <div class="stat-item">
                <div class="stat-val" id="out-v2">--</div>
                <div class="stat-label">Final Speed $v_2$</div>
            </div>
        </div>
    </main>
</div>

<script>
    // --- Configuration ---
    const COLORS = {
        m1: '#3b82f6', // Soft Blue
        m2: '#ec4899', // Soft Pink
        bg: '#f8fafc',
        grid: 'rgba(0,0,0,0.05)'
    };

    const cvsLab = document.getElementById('cvs-lab');
    const cvsCm = document.getElementById('cvs-cm');
    const ctxLab = cvsLab.getContext('2d');
    const ctxCm = cvsCm.getContext('2d');

    // Resize Canvas for Retina/HighDPI
    function resizeCanvas(canvas) {
        const rect = canvas.parentElement.getBoundingClientRect();
        canvas.width = rect.width;
        canvas.height = 400;
    }
    window.addEventListener('resize', () => { resizeCanvas(cvsLab); resizeCanvas(cvsCm); });
    resizeCanvas(cvsLab); resizeCanvas(cvsCm);

    // --- State ---
    let state = { 
        running: false, 
        t: 0, 
        animId: null,
        trails: { cm: [], lab: [] } // History for drawing trails
    };
    let data = {};
    let scaleFactor = 1;

    // --- Physics Core ---
    function calculate() {
        const m1 = parseFloat(document.getElementById('m1').value);
        const m2 = parseFloat(document.getElementById('m2').value);
        const u1 = parseFloat(document.getElementById('u1').value);
        const u2 = parseFloat(document.getElementById('u2').value);
        const e = parseFloat(document.getElementById('e').value);
        const chi = parseFloat(document.getElementById('chi').value) * Math.PI / 180;

        // 1. Vcm Calculation
        const Vcm = (m1*u1 + m2*u2)/(m1+m2);

        // 2. CM Frame Velocities (Initial)
        const u1p = u1 - Vcm;
        const u2p = u2 - Vcm;

        // 3. CM Frame Velocities (Final Magnitude)
        const v1p_mag = e * Math.abs(u1p);
        const v2p_mag = e * Math.abs(u2p);

        // 4. Vectors (Scattering)
        // u1p is along X axis. v1p is rotated by chi.
        // Note: u1p can be negative, so we use sign to determine direction
        const dir = Math.sign(u1p); 
        
        const v1p = { 
            x: v1p_mag * Math.cos(chi) * dir, // Preserves direction logic
            y: -v1p_mag * Math.sin(chi)       // Scatters Up
        };
        
        const v2p = {
            x: v2p_mag * Math.cos(Math.PI + chi) * dir, // Opposite
            y: -v2p_mag * Math.sin(Math.PI + chi)
        };

        // 5. Lab Vectors
        const v1L = { x: v1p.x + Vcm, y: v1p.y };
        const v2L = { x: v2p.x + Vcm, y: v2p.y };

        // 6. Auto Scale
        const maxVel = Math.max(Math.abs(u1), Math.abs(u2), Math.hypot(v1L.x, v1L.y));
        scaleFactor = 150 / (maxVel * 1.2 + 1); // Pixels per meter (approx)

        return { 
            m1, m2, u1, u2, Vcm, u1p, u2p, v1p, v2p, v1L, v2L,
            KE_loss: 0.5*m1*u1**2 + 0.5*m2*u2**2 - (0.5*m1*(v1L.x**2+v1L.y**2) + 0.5*m2*(v2L.x**2+v2L.y**2))
        };
    }

    // --- Animation ---
    document.getElementById('btn-run').addEventListener('click', () => {
        if(state.running) {
            state.running = false;
            cancelAnimationFrame(state.animId);
            document.getElementById('btn-run').textContent = "INITIALIZE SYSTEM";
            document.getElementById('btn-run').style.background = "linear-gradient(90deg, var(--neon-blue), #8b5cf6)";
        } else {
            data = calculate();
            state.t = 0;
            state.trails = { cm: [], lab: [] }; // Reset trails
            state.running = true;
            document.getElementById('btn-run').textContent = "ABORT SIMULATION";
            document.getElementById('btn-run').style.background = "linear-gradient(90deg, #ef4444, #b91c1c)";
            
            // Update Stats
            document.getElementById('out-vcm').textContent = data.Vcm.toFixed(2);
            document.getElementById('out-loss').textContent = data.KE_loss.toFixed(2) + " J";
            document.getElementById('out-v1').textContent = Math.hypot(data.v1L.x, data.v1L.y).toFixed(2);
            document.getElementById('out-v2').textContent = Math.hypot(data.v2L.x, data.v2L.y).toFixed(2);

            loop();
        }
    });

    function loop() {
        if(!state.running) return;
        state.t += 0.005; // Speed
        if(state.t > 1) {
            state.running = false;
            document.getElementById('btn-run').textContent = "RE-INITIALIZE";
            document.getElementById('btn-run').style.background = "linear-gradient(90deg, #10b981, #059669)";
            draw(1);
            return;
        }
        draw(state.t);
        state.animId = requestAnimationFrame(loop);
    }

    // --- Rendering ---
    function draw(t) {
        const w = cvsLab.width; const h = cvsLab.height;
        const cx = w/2; const cy = h/2;

        // Clear
        ctxLab.clearRect(0,0,w,h); ctxCm.clearRect(0,0,w,h);
        
        // Draw Holographic Grid
        drawGrid(ctxLab, w, h); drawGrid(ctxCm, w, h);

        // Calculate Positions based on time t
        // t=0.5 is collision
        const split = 0.5;
        let posL = {}, posC = {};
        
        // Sim Time (duration logic)
        // We map t (0->1) to simulation time (-1s to +1s approx)
        const simT = (t - split) * 2.0; 

        // Logic:
        // Before collision: Pos = Vel_initial * time (where time is negative)
        // After collision: Pos = Vel_final * time (where time is positive)
        
        if(t <= split) {
            // Approach
            posC.m1 = { x: data.u1p * simT, y: 0 };
            posC.m2 = { x: data.u2p * simT, y: 0 };
            
            // Lab: Camera centered on impact point
            posL.m1 = { x: data.u1 * simT, y: 0 };
            posL.m2 = { x: data.u2 * simT, y: 0 };
        } else {
            // Scatter
            posC.m1 = { x: data.v1p.x * simT, y: data.v1p.y * simT };
            posC.m2 = { x: data.v2p.x * simT, y: data.v2p.y * simT };

            posL.m1 = { x: data.v1L.x * simT, y: data.v1L.y * simT };
            posL.m2 = { x: data.v2L.x * simT, y: data.v2L.y * simT };
        }

        // Convert to Canvas Coords (Center + Scale)
        const toCvs = (p) => ({ x: cx + p.x * scaleFactor, y: cy + p.y * scaleFactor });
        
        const pL1 = toCvs(posL.m1); const pL2 = toCvs(posL.m2);
        const pC1 = toCvs(posC.m1); const pC2 = toCvs(posC.m2);

        // Store Trails (Only every 3rd frame to save perf)
        if(Math.floor(t*1000)%3 === 0) {
            state.trails.lab.push({m1:pL1, m2:pL2});
            state.trails.cm.push({m1:pC1, m2:pC2});
        }

        // Draw Trails (The Graph Fix)
        drawTrail(ctxLab, state.trails.lab, COLORS.m1, 'm1');
        drawTrail(ctxLab, state.trails.lab, COLORS.m2, 'm2');
        drawTrail(ctxCm, state.trails.cm, COLORS.m1, 'm1');
        drawTrail(ctxCm, state.trails.cm, COLORS.m2, 'm2');

        // Draw Balls
        drawNeonBall(ctxLab, pL1.x, pL1.y, data.m1, COLORS.m1, "M1");
        drawNeonBall(ctxLab, pL2.x, pL2.y, data.m2, COLORS.m2, "M2");

        drawNeonBall(ctxCm, pC1.x, pC1.y, data.m1, COLORS.m1, "M1");
        drawNeonBall(ctxCm, pC2.x, pC2.y, data.m2, COLORS.m2, "M2");

        // Draw HUD Details (Moving with ball)
        // Calculate current velocities for display
        const v1_curr = t<=0.5 ? data.u1 : Math.hypot(data.v1L.x, data.v1L.y);
        const v2_curr = t<=0.5 ? data.u2 : Math.hypot(data.v2L.x, data.v2L.y);
        
        drawInfoHUD(ctxLab, pL1.x, pL1.y, `v:${v1_curr.toFixed(1)}`, COLORS.m1, -30);
        drawInfoHUD(ctxLab, pL2.x, pL2.y, `v:${v2_curr.toFixed(1)}`, COLORS.m2, 30);

        // CM Crosshair
        drawCrosshair(ctxCm, cx, cy);
    }

    // --- Graphics Helpers ---
    
    function drawGrid(ctx, w, h) {
        ctx.strokeStyle = 'rgba(0,0,0,0.05)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        for(let x=0; x<w; x+=40) { ctx.moveTo(x,0); ctx.lineTo(x,h); }
        for(let y=0; y<h; y+=40) { ctx.moveTo(0,y); ctx.lineTo(w,y); }
        ctx.stroke();
    }

    function drawCrosshair(ctx, x, y) {
        ctx.strokeStyle = 'rgba(16, 185, 129, 0.3)';
        ctx.lineWidth = 1;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(x, 0); ctx.lineTo(x, ctx.canvas.height);
        ctx.moveTo(0, y); ctx.lineTo(ctx.canvas.width, y);
        ctx.stroke();
        ctx.setLineDash([]);
    }

    function drawTrail(ctx, history, color, key) {
        if(history.length < 2) return;
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.globalAlpha = 0.4; // Trail fade
        ctx.beginPath();
        ctx.moveTo(history[0][key].x, history[0][key].y);
        for(let i=1; i<history.length; i++) {
            ctx.lineTo(history[i][key].x, history[i][key].y);
        }
        ctx.stroke();
        ctx.globalAlpha = 1.0;
    }

    function drawNeonBall(ctx, x, y, m, color, label) {
        const r = 10 + 4 * Math.cbrt(m); // Cube root sizing
        
        // 1. Outer Glow
        ctx.shadowBlur = 15;
        ctx.shadowColor = color;
        
        // 2. Gradient Fill (Glass effect)
        const grad = ctx.createRadialGradient(x-r/3, y-r/3, r/5, x, y, r);
        grad.addColorStop(0, '#ffffff');
        grad.addColorStop(0.4, color);
        grad.addColorStop(1, '#e2e8f0'); // Light edge for 3D
        
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI*2);
        ctx.fill();
        
        ctx.shadowBlur = 0; // Reset shadow for text
        
        // 3. Center Label
        ctx.fillStyle = "#fff";
        ctx.font = "bold 9px Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(label, x, y);
    }

    function drawInfoHUD(ctx, x, y, text, color, offsetY) {
        ctx.font = "10px monospace";
        const width = ctx.measureText(text).width + 8;
        const h = 14;
        
        // Background Box
        ctx.fillStyle = "rgba(255,255,255,0.9)";
        ctx.strokeStyle = color;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.roundRect(x - width/2, y + offsetY - h/2, width, h, 4);
        ctx.fill();
        ctx.stroke();

        // Text
        ctx.fillStyle = color;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(text, x, y + offsetY);
        
        // Connecting Line
        ctx.beginPath();
        ctx.moveTo(x, y + (offsetY > 0 ? 15 : -15));
        ctx.lineTo(x, y + (offsetY > 0 ? offsetY - h/2 : offsetY + h/2));
        ctx.stroke();
    }

    // Init
    calculate();
</script>
</body>
</html>