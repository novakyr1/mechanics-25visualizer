<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced 2D Elastic Collision Suite</title>
    <style>
        :root {
            --bg-color: #0f172a;
            --panel-bg: rgba(30, 41, 59, 0.7);
            --text-main: #e2e8f0;
            --text-muted: #94a3b8;
            --accent-primary: #38bdf8; /* Cyan */
            --accent-secondary: #f472b6; /* Pink */
            --accent-cm: #4ade80; /* Green */
            --glow-strength: 10px;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-main);
            background-image: 
                radial-gradient(circle at 10% 20%, rgba(56, 189, 248, 0.1) 0%, transparent 20%),
                radial-gradient(circle at 90% 80%, rgba(244, 114, 182, 0.1) 0%, transparent 20%);
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        h1 {
            font-weight: 300;
            letter-spacing: 1px;
            margin: 0;
            background: linear-gradient(90deg, var(--accent-primary), var(--accent-secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-size: 2.5rem;
        }

        .subtitle {
            color: var(--text-muted);
            font-size: 0.9rem;
            margin-top: 5px;
        }

        /* Grid Layout */
        .main-grid {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 20px;
        }

        @media (max-width: 900px) {
            .main-grid { grid-template-columns: 1fr; }
        }

        /* Panels */
        .panel {
            background: var(--panel-bg);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 20px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }

        /* Controls */
        .control-group {
            margin-bottom: 20px;
        }

        label {
            display: flex;
            justify-content: space-between;
            font-size: 0.85rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text-muted);
        }

        .value-badge {
            background: rgba(255,255,255,0.1);
            padding: 2px 8px;
            border-radius: 4px;
            color: var(--text-main);
            font-family: monospace;
        }

        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 6px;
            background: rgba(255,255,255,0.1);
            border-radius: 3px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: var(--accent-primary);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 var(--glow-strength) var(--accent-primary);
            transition: transform 0.1s;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        /* Buttons */
        .btn-primary {
            width: 100%;
            padding: 12px;
            background: linear-gradient(135deg, var(--accent-primary), #0ea5e9);
            border: none;
            border-radius: 8px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.3s ease;
            box-shadow: 0 0 15px rgba(56, 189, 248, 0.3);
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 0 25px rgba(56, 189, 248, 0.5);
        }

        /* Canvas Area */
        .canvas-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        @media (max-width: 1100px) {
            .canvas-container { grid-template-columns: 1fr; }
        }

        .canvas-wrapper {
            position: relative;
            background: rgba(0,0,0,0.3);
            border-radius: 12px;
            overflow: hidden;
            border: 1px solid rgba(255,255,255,0.05);
        }

        .frame-label {
            position: absolute;
            top: 15px;
            left: 15px;
            background: rgba(0,0,0,0.6);
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 0.8rem;
            color: var(--accent-primary);
            border-left: 3px solid var(--accent-primary);
        }

        canvas {
            display: block;
            width: 100%;
        }

        /* Data Dashboard */
        .dashboard {
            margin-top: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }

        .metric-card {
            background: rgba(255,255,255,0.03);
            padding: 10px;
            border-radius: 8px;
            text-align: center;
        }

        .metric-title {
            font-size: 0.75rem;
            color: var(--text-muted);
            text-transform: uppercase;
        }

        .metric-value {
            font-size: 1.1rem;
            font-weight: bold;
            margin-top: 5px;
            font-family: monospace;
        }

        .formula-display {
            margin-top: 10px;
            text-align: center;
            font-family: 'Times New Roman', serif;
            font-style: italic;
            font-size: 0.9rem;
            color: var(--text-muted);
            opacity: 0.8;
        }

        /* Legend */
        .legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 20px;
            padding: 10px;
            background: rgba(255,255,255,0.05);
            border-radius: 50px;
            width: fit-content;
            margin-left: auto;
            margin-right: auto;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.8rem;
        }

        .dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

    </style>
</head>
<body>

<div class="container">
    <header>
        <h1>Elastic Collision Simulator</h1>
        <div class="subtitle">Interactive Laboratory & Center-of-Mass Frame Analysis</div>
    </header>

    <div class="main-grid">
        <div class="panel">
            <h3 style="margin-top:0; color:white; border-bottom:1px solid #ffffff22; padding-bottom:10px;">Parameters</h3>
            
            <div class="control-group">
                <label for="mass1">Mass 1 (m₁) <span class="value-badge" id="mass1-value">3.0 kg</span></label>
                <input type="range" id="mass1" min="1" max="15" step="0.5" value="3">
            </div>
            
            <div class="control-group">
                <label for="mass2">Mass 2 (m₂) <span class="value-badge" id="mass2-value">5.0 kg</span></label>
                <input type="range" id="mass2" min="1" max="15" step="0.5" value="5">
            </div>
            
            <div class="control-group">
                <label for="velocity">Velocity (u₁) <span class="value-badge" id="velocity-value">5.0 m/s</span></label>
                <input type="range" id="velocity" min="1" max="20" step="0.5" value="10">
            </div>
            
            <div class="control-group">
                <label for="scattering-angle">CM Scattering (θ) <span class="value-badge" id="angle-value">60°</span></label>
                <input type="range" id="scattering-angle" min="0" max="180" value="60">
            </div>

            <button id="play-pause" class="btn-primary">Start Simulation</button>

            <div style="margin-top: 20px; font-size: 0.8rem; color: var(--text-muted); line-height: 1.4;">
                <p><strong>Note:</strong> In the Lab Frame, m₂ is initially at rest.</p>
            </div>
        </div>

        <div style="display: flex; flex-direction: column; gap: 20px;">
            
            <div class="canvas-container">
                <div class="canvas-wrapper">
                    <div class="frame-label">LABORATORY FRAME</div>
                    <canvas id="lab-frame" width="450" height="350"></canvas>
                    <div class="formula-display" id="lab-formula">Vcm = ...</div>
                </div>
                <div class="canvas-wrapper">
                    <div class="frame-label">CENTER-OF-MASS FRAME</div>
                    <canvas id="cm-frame" width="450" height="350"></canvas>
                    <div class="formula-display">u₁' = -u₂' (Zero Momentum)</div>
                </div>
            </div>

            <div class="panel">
                <div class="legend">
                    <div class="legend-item"><div class="dot" style="background:var(--accent-secondary); box-shadow: 0 0 5px var(--accent-secondary);"></div> Mass 1</div>
                    <div class="legend-item"><div class="dot" style="background:var(--accent-primary); box-shadow: 0 0 5px var(--accent-primary);"></div> Mass 2</div>
                    <div class="legend-item"><div class="dot" style="background:var(--accent-cm); box-shadow: 0 0 5px var(--accent-cm);"></div> Center of Mass</div>
                </div>

                <div class="dashboard">
                    <div class="metric-card">
                        <div class="metric-title">Lab Scattering θ₁</div>
                        <div class="metric-value" id="val-theta1">--°</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-title">Lab Recoil θ₂</div>
                        <div class="metric-value" id="val-theta2">--°</div>
                    </div>
                    <div class="metric-card" style="border: 1px solid rgba(74, 222, 128, 0.3);">
                        <div class="metric-title" style="color: var(--accent-cm);">System Kinetic Energy</div>
                        <div class="metric-value" style="color: var(--accent-cm);" id="val-energy">-- J</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-title">Final Speed v₁</div>
                        <div class="metric-value" id="val-v1">--</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    // --- Configuration & Constants ---
    const COLORS = {
        m1: '#f472b6', // Pink
        m2: '#38bdf8', // Blue
        cm: '#4ade80', // Green
        grid: 'rgba(255, 255, 255, 0.05)',
        text: '#e2e8f0'
    };

    // --- DOM Elements ---
    const canvasLab = document.getElementById('lab-frame');
    const ctxLab = canvasLab.getContext('2d');
    const canvasCm = document.getElementById('cm-frame');
    const ctxCm = canvasCm.getContext('2d');

    const controls = {
        m1: document.getElementById('mass1'),
        m2: document.getElementById('mass2'),
        u1: document.getElementById('velocity'),
        theta: document.getElementById('scattering-angle'),
        btn: document.getElementById('play-pause')
    };

    const displays = {
        m1: document.getElementById('mass1-value'),
        m2: document.getElementById('mass2-value'),
        u1: document.getElementById('velocity-value'),
        theta: document.getElementById('angle-value'),
        labFormula: document.getElementById('lab-formula'),
        valTheta1: document.getElementById('val-theta1'),
        valTheta2: document.getElementById('val-theta2'),
        valEnergy: document.getElementById('val-energy'),
        valV1: document.getElementById('val-v1')
    };

    // --- State ---
    let state = {
        isPlaying: false,
        progress: 0,
        animId: null
    };

    // --- Event Listeners ---
    Object.values(controls).forEach(el => {
        if(el.type === 'range') el.addEventListener('input', updateSimulation);
    });
    controls.btn.addEventListener('click', toggleAnimation);

    // --- Physics Core ---
    function calculatePhysics() {
        const m1 = parseFloat(controls.m1.value);
        const m2 = parseFloat(controls.m2.value);
        const u1 = parseFloat(controls.u1.value);
        const thetaDeg = parseFloat(controls.theta.value);
        const thetaRad = thetaDeg * Math.PI / 180;

        // 1. Center of Mass Velocity (Lab Frame)
        const Vcm = (m1 * u1) / (m1 + m2);

        // 2. Initial velocities in CM Frame
        // u1' = u1 - Vcm = m2*u1 / (m1+m2)
        const u1_prime = (m2 * u1) / (m1 + m2);
        const u2_prime = - (m1 * u1) / (m1 + m2); // Negative direction

        // 3. Lab Frame Scattering Angles
        // tan(theta1) = sin(theta) / (cos(theta) + m1/m2)
        const tanTheta1 = Math.sin(thetaRad) / (Math.cos(thetaRad) + (m1/m2));
        const theta1 = Math.atan(tanTheta1);
        const theta2 = (Math.PI - thetaRad) / 2;

        // 4. Final Velocities (Lab Frame) via cosine rule or vector addition
        // v1^2 = v1'^2 + Vcm^2 + 2*v1'*Vcm*cos(theta)
        // elastic collision in CM: magnitude v1' = u1'
        const v1_final = Math.sqrt(u1_prime**2 + Vcm**2 + 2*u1_prime*Vcm*Math.cos(thetaRad));
        const v2_final = Math.sqrt(u2_prime**2 + Vcm**2 + 2*Math.abs(u2_prime)*Vcm*Math.cos(Math.PI - thetaRad)); // slightly complex due to vector direction, simplified below

        // Energy Check (Initial Kinetic Energy)
        const KE = 0.5 * m1 * u1 * u1;

        return {
            m1, m2, u1, thetaRad, Vcm, u1_prime, u2_prime, theta1, theta2, KE, v1_final
        };
    }

    // --- Animation Logic ---
    function toggleAnimation() {
        state.isPlaying = !state.isPlaying;
        controls.btn.textContent = state.isPlaying ? 'Pause Simulation' : 'Start Simulation';
        controls.btn.style.background = state.isPlaying 
            ? 'linear-gradient(135deg, #ef4444, #b91c1c)' // Red for Stop
            : 'linear-gradient(135deg, var(--accent-primary), #0ea5e9)'; // Blue for Start
        
        if (state.isPlaying) {
            if (state.progress >= 1) state.progress = 0; // Auto reset if finished
            loop();
        } else {
            cancelAnimationFrame(state.animId);
        }
    }

    function loop() {
        if (!state.isPlaying) return;

        state.progress += 0.005; // Speed
        if (state.progress >= 1) {
            state.progress = 1;
            state.isPlaying = false;
            controls.btn.textContent = "Restart Simulation";
            controls.btn.style.background = 'linear-gradient(135deg, #10b981, #059669)'; // Green for restart
        }

        draw();
        if (state.isPlaying) {
            state.animId = requestAnimationFrame(loop);
        }
    }

    // Easing function for smoother motion
    function easeInOutQuad(t) {
        return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
    }

    // --- Drawing System ---
    function updateSimulation() {
        // Update Labels
        displays.m1.textContent = controls.m1.value + ' kg';
        displays.m2.textContent = controls.m2.value + ' kg';
        displays.u1.textContent = controls.u1.value + ' m/s';
        displays.theta.textContent = controls.theta.value + '°';

        const phys = calculatePhysics();
        
        displays.labFormula.innerHTML = `V<sub>cm</sub> = ${phys.Vcm.toFixed(2)} m/s`;
        displays.valTheta1.textContent = (phys.theta1 * 180/Math.PI).toFixed(1) + '°';
        displays.valTheta2.textContent = (phys.theta2 * 180/Math.PI).toFixed(1) + '°';
        displays.valEnergy.textContent = phys.KE.toFixed(1) + ' J';
        displays.valV1.textContent = phys.v1_final.toFixed(2) + ' m/s';

        if (!state.isPlaying) draw();
    }

    function draw() {
        const phys = calculatePhysics();
        const w = canvasLab.width;
        const h = canvasLab.height;
        
        // 1. Draw Lab Frame
        drawScene(ctxLab, w, h, phys, 'lab');
        
        // 2. Draw CM Frame
        drawScene(ctxCm, w, h, phys, 'cm');
    }

    function drawScene(ctx, width, height, phys, type) {
        // Clear & Background
        ctx.clearRect(0, 0, width, height);
        drawGrid(ctx, width, height);

        const cy = height / 2;
        const cx = width / 2;
        
        // Normalize progress for phases
        // Phase 1: Approach (0 -> 0.45)
        // Phase 2: Collision (0.45 -> 0.55)
        // Phase 3: Separation (0.55 -> 1.0)
        
        let p = state.progress;
        let m1Pos = {x:0, y:0}, m2Pos = {x:0, y:0};
        let alphaInfo = 1; // For text fade

        // --- LAB FRAME LOGIC ---
        if (type === 'lab') {
            const Vcm_px = phys.Vcm * 10; // scale factor
            
            // Draw CM Marker (moves in Lab Frame)
            const cmStartX = 100;
            const cmTravel = (width - 200);
            const cmX = cmStartX + cmTravel * p; // CM moves constantly
            
            drawCMReticule(ctx, cmX, cy);

            if (p < 0.5) {
                // Approach
                const time = p / 0.5; // 0 to 1
                // m2 is stationary initially relative to ground? No, wait.
                // In Lab frame, m2 is at rest initially.
                // But we want the collision to happen at the specific CM point at t=0.5.
                
                // Let's simplify visual logic: Collision happens at screen center for visuals?
                // No, Lab frame collision happens where m2 is.
                // Let's fix collision point at width/2 for simplicity in viewing
                
                const collisionX = width / 2;
                
                // m2 is at collisionX waiting
                m2Pos = { x: collisionX, y: cy };
                
                // m1 comes from left. dist = v * t
                // We animate backwards from collision point
                const dist = 180; 
                m1Pos = { x: collisionX - dist * (1-time), y: cy };
                
                drawVector(ctx, m1Pos.x, m1Pos.y, phys.u1 * 5, 0, COLORS.m1);
                
                ctx.fillStyle = COLORS.text;
                ctx.font = "12px monospace";
                ctx.fillText("Before Collision", 20, 40);

            } else {
                // Separation
                const time = (p - 0.5) / 0.5; // 0 to 1
                const collisionX = width / 2;
                
                // m1 moves at angle theta1
                // Speed scaling is purely visual but proportional
                const speedScale = 180;
                
                // Calculate Lab Final Velocities components for visual
                // v1 = vector sum of v1' + Vcm
                // Simplified visual ray casting based on angles
                const dist1 = speedScale * time * (phys.v1_final / phys.u1); // relative speed
                m1Pos = {
                    x: collisionX + dist1 * Math.cos(phys.theta1),
                    y: cy - dist1 * Math.sin(phys.theta1)
                };

                // m2
                // Conservation of momentum: m1v1y + m2v2y = 0 -> m2 moves down
                const dist2 = speedScale * time * 0.8; // approximation for visual
                m2Pos = {
                    x: collisionX + dist2 * Math.cos(phys.theta2),
                    y: cy + dist2 * Math.sin(phys.theta2)
                };

                drawVector(ctx, m1Pos.x, m1Pos.y, 30, -phys.theta1, COLORS.m1);
                drawVector(ctx, m2Pos.x, m2Pos.y, 30, phys.theta2, COLORS.m2);

                ctx.fillStyle = COLORS.text;
                ctx.fillText("After Collision", 20, 40);
            }

        } 
        // --- CM FRAME LOGIC ---
        else {
            drawCMReticule(ctx, cx, cy); // CM is fixed at center

            if (p < 0.5) {
                const time = p / 0.5; // 0 to 1
                const dist = 150 * (1 - time);
                
                m1Pos = { x: cx - dist, y: cy }; // Comes from left
                m2Pos = { x: cx + dist, y: cy }; // Comes from right

                drawVector(ctx, m1Pos.x, m1Pos.y, phys.u1_prime * 4, 0, COLORS.m1);
                drawVector(ctx, m2Pos.x, m2Pos.y, phys.u2_prime * 4, Math.PI, COLORS.m2); // Point left
                
                ctx.fillStyle = COLORS.text;
                ctx.fillText("Approach (Net Momentum = 0)", 20, 40);
            } else {
                const time = (p - 0.5) / 0.5;
                const dist = 150 * time;
                
                // Scatter at angle theta
                m1Pos = {
                    x: cx + dist * Math.cos(phys.thetaRad),
                    y: cy - dist * Math.sin(phys.thetaRad)
                };
                
                m2Pos = {
                    x: cx - dist * Math.cos(phys.thetaRad),
                    y: cy + dist * Math.sin(phys.thetaRad)
                };

                // Draw scattering arc
                ctx.strokeStyle = 'rgba(255,255,255,0.1)';
                ctx.beginPath();
                ctx.arc(cx, cy, 40, 0, -phys.thetaRad, true);
                ctx.stroke();
                ctx.fillStyle = 'rgba(255,255,255,0.5)';
                ctx.fillText("θ", cx + 45, cy - 10);

                drawVector(ctx, m1Pos.x, m1Pos.y, 40, -phys.thetaRad, COLORS.m1);
                drawVector(ctx, m2Pos.x, m2Pos.y, 40, Math.PI - phys.thetaRad, COLORS.m2);
                
                ctx.fillStyle = COLORS.text;
                ctx.fillText("Scattering", 20, 40);
            }
        }

        // Draw Particles
        drawBall(ctx, m1Pos.x, m1Pos.y, 8 + phys.m1, COLORS.m1);
        drawBall(ctx, m2Pos.x, m2Pos.y, 8 + phys.m2, COLORS.m2);

        // Collision Flash
        if (p > 0.48 && p < 0.52) {
            ctx.fillStyle = `rgba(255, 255, 255, ${1 - Math.abs(0.5-p)*50})`;
            ctx.globalCompositeOperation = 'screen';
            ctx.fillRect(0, 0, width, height);
            ctx.globalCompositeOperation = 'source-over';
        }
    }

    // --- Helper Drawing Functions ---

    function drawGrid(ctx, w, h) {
        ctx.strokeStyle = COLORS.grid;
        ctx.lineWidth = 1;
        ctx.beginPath();
        for (let x = 0; x < w; x += 40) { ctx.moveTo(x, 0); ctx.lineTo(x, h); }
        for (let y = 0; y < h; y += 40) { ctx.moveTo(0, y); ctx.lineTo(w, y); }
        ctx.stroke();
    }

    function drawCMReticule(ctx, x, y) {
        ctx.strokeStyle = COLORS.cm;
        ctx.lineWidth = 1;
        ctx.setLineDash([4, 4]);
        ctx.beginPath();
        ctx.moveTo(x, 0); ctx.lineTo(x, ctx.canvas.height);
        ctx.stroke();
        ctx.setLineDash([]);
        
        ctx.fillStyle = COLORS.cm;
        ctx.beginPath();
        ctx.arc(x, y, 4, 0, Math.PI*2);
        ctx.fill();
        ctx.font = "10px sans-serif";
        ctx.fillText("CM", x+6, y-6);
    }

    function drawBall(ctx, x, y, r, color) {
        // Glow effect
        ctx.shadowBlur = 15;
        ctx.shadowColor = color;
        
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.fill();
        
        // Highlight
        ctx.fillStyle = 'rgba(255,255,255,0.3)';
        ctx.beginPath();
        ctx.arc(x - r*0.3, y - r*0.3, r*0.4, 0, Math.PI * 2);
        ctx.fill();

        ctx.shadowBlur = 0; // Reset
    }

    function drawVector(ctx, x, y, len, angle, color) {
        const toX = x + len * Math.cos(angle);
        const toY = y + len * Math.sin(angle);
        
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(toX, toY);
        ctx.stroke();
        
        // Arrowhead
        const headLen = 6;
        ctx.beginPath();
        ctx.moveTo(toX, toY);
        ctx.lineTo(toX - headLen * Math.cos(angle - Math.PI/6), toY - headLen * Math.sin(angle - Math.PI/6));
        ctx.lineTo(toX - headLen * Math.cos(angle + Math.PI/6), toY - headLen * Math.sin(angle + Math.PI/6));
        ctx.fillStyle = color;
        ctx.fill();
    }

    // Initial Render
    updateSimulation();

</script>
</body>
</html>
